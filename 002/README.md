# pointer
반갑습니다. Cpprhtn입니다.

사실 포인터는 C++로 넘어오면서 레퍼런스와 혼동하여 쓰이기 쉽습니다.

그렇기에 둘의 차이를 확실하게 잡고 갈 생각입니다.


포인터
- (1)메모리 상에 위치한 특정한 데이터의 (시작)주소값을 보관하는 변수입니다.

(1)에서
포인터의 정의를
(포인터에 주소값이 저장되는 데이터의 형)  *(포인터의 이름);
이라고 할 수 있습니다.
예를 들어 p 라는 포인터가 int 데이터를 가리키고 싶다고 하면

int *p;라고 하면 됩니다
즉 포인터 p 는 int 형 데이터의 주소값을 저장하는 변수가 되는 것 입니다
포인터를 정의하였으면 주소값을 넣어야 하는데 우리는 주소값을 알지 못합니다.
그래서  우리는 &연산자를 사용하여 주소값에 접근합니다.
& (주소값을 계산할 데이터)의 형태로 말입니다.

현재까지의 포인터의 개념을 다시 정리하자면
포인터는 특정한 데이터의 주소값을 보관한다. 이 때 포인터는 주소값을 보관하는 데이터의 형에 * 를 붙임으로써 정의되고, & 연산자로 특정한 데이터의 메모리 상의 주소값을 알아올 수 있다. 또한 한번 정의된 주소값은 변하지 않는다.

포인터의 마지막 개념은 * 표 입니다
```C++
int main() {
  int *p;
  int a;

  p = &a;
  a = 5;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);
}
```
이 코드에서 포인터 p와 a를 정의하고, p=a의 주솟값으로, 그리고 5는 5라고 선언했습니다.
그리고 a와 *p의 값을 출력했는데
여기서의 출력값을 둘다 5입니다.

a의 값을 출력하는것은 5가 당연합니다.
그렇다면 여기서 출력하는 *p의 의미는 무엇일까요?
바로 *p는 자신에게 저장된 주솟값의 데이터를 불러오는 것입니다.
이 말은 *p에 저장된 &a,즉 a의 주솟값이 p에 저장이 되어있고,
*p를 통해 p의 주솟값인 &a의 데이터 a=5의 값을 불러오는 것입니다. 

또다른 소스를 봅시다.
```C++
int main() {
  int a;
  int b;
  int *p;

  p = &a;
  *p = 1;
  p = &b;
  *p = 2;

  printf("%d \n", a);
  printf("%d \n", b);
  return 0;
}
```
여기서 a와 b의 출력값은 1과 2입니다.
처음에 p는 a의 주솟값을 가지는데, *p=1, 즉 그 주솟값에 있는 데이터 값이 1이되므로
자연스레 a의 데이터 값도 1이 됩니다.
그 다음에 b의 주솟값으로 바뀝니다. *p도 변수이기 때문이죠.
같은 방법으로 b의 데이터 값은 2가 됩니다.


- (2)동적으로 할당한 메모리로 얻을 수 있는 다른 변수의 주소일 수도 있습니다.

(2)에서
동적인 크기의 배열을 할당한다고 합시다.
```C++
int *y = new int[10];
```

이 배열은 int 타입 요소가 10개인 배열을 할당합니다.
동적 할당을 통해 런타임에 배열의 크기를 정할 수 있습니다.

포인터는 배열과 같은 위험이 있습니다.
범위를 벗어난 데이터에 접근하면 프로그램에 충돌이 발생하거나 데이터가 무효화 될 수 있기 떄문입니다.
동적으로 할당한 배열을 처리할 때 배열 크기를 저장하는 것은 프로그래머의 책임입니다.
또한 필요하지 않은 메모리는 해제해야합니다.

메모리의 해제는 다음과  같은방법으로 실행합니다.
```C++
delete[] v;
```
함수의 매개변수가 배열인 경우 내부적으로 포인터로 취급하기 때문에 아래의 vector_add함수는
포인터와 함께 동작함을 알 수 있습니다.
```C++
void vecotr_add(unsigned size, const double v1[], const double v2[], double s[])
{
for (unsigned i=0; i < size; ++i)
s[i] = v1[i] + v2[i];
}
int main(int argc, char *argv[])
{
double *x = new double[3], *y = new double[3], *sum = new double[3];
for (unsigned i=0; i < 3; ++i)
x[i] = i + 2, y[i] = 4.2 * I;
vector_add(3, x, y, sum);
...
}
```
포인터의 간단한 사용 방법은 하나의 단일 데이터 항목을 동적으로 할당하는 방법입니다.
```C++
int *ip = new int;
```

또한 이 메모리를 해제하는 방법은 아래와 같습니다.

```C++
delete ip; 
```
그러나 할당과 해제의 이중성에 조심해야 합니다.
단일 개체 할당에서는 단일 개체 해제가 필요하다. 배열 할당에서도 배열 해제가 필요합니다.
만약 그렇지 않으면 런타임 시스템이 해제를 잘못 처리해 이 시점에서 크래시가 발생할 가능성이 큽니다.

초기화 하지 않은 포인터에는 무작위 값을 할당한다. 따라 초기화 하지 못한 포인터를 사용하면
수많은 에러를 발견 할 수도 있습니다. 

포인터가 가르키는 것이 없다는것을 알려주는 것은 아래와 같습니다.
```C++
int *ip = nullptr; //
int *ip{}; //둘다 같은말
```

```C++
int *ip = NULL; 과 같은 형태는 추천하지 않는 것이 아니라 그냥 사용하지 말기를 권합니다.
```

포인터의 가장 큰 위험은 메모리 누수입니다.
예를 들어 배열 y에 더 큰 새로운 배열을 할당한다고 가정합시다.
```C++
int *y = new int[30];
```
이전보다 더 많은 공간을 쓸 수 있게 됩니다. 
하지만 우리가 할당했던 메모리는 "있었는데요 없었습니다"와 같은 상황이 발생합니다.
여전히 그곳에 있지만, 더이상 접근할 수 없는 상태가 됩니다. 뒤늦게 그 메모리를 해제하려고 해도
우리는 그 주소를 모르기 때문에 해제할 수도 없습니다. 여기서 누락된 메모리들은 프로그램을 돌면서 
쓸데없는 메모리를 잡아먹습니다. 프로그램이 종료된 후에야 해당 메모리를 해제할 수 있습니다.

초보자들은 숨만 쉬어도 메모리 잡아먹는 소리가 들릴정도로 실수가 빈번합니다. 
앞선 심각한 오류들도 친구보다 많이 만날정도로요.
그래서 포인터를 사용할때는 늘 조심스럽게 사용합시다.

int **a와 같이 더블포인터(이중포인터)또한 존재합니다.
```C++
#include <iostream>
using namespace std;
int main() 
{
    int* ptr;
    int** ptrr;
    int num;
    ptrr = &ptr; // int** 형에는 int**(&*)형을 대입.
    ptr = &num;    num = 2;
    cout << "ptr의 값(num의 주소값) : " << ptr << endl;
    cout << "*ptr의 값(num의 값) : " << *ptr << endl;
    cout << "num의 주소값 : " << &num << endl;
    cout << "num의 값 : " << num << endl;
    cout << endl;
    cout << "&ptr의 값(ptr의 주소값) : " << &ptr << endl;
    cout << "&*ptr의 값(num의 주소값) : " << &*ptr << endl;
    cout << endl;
    cout << "ptrr의 값(ptr의 주소값) : " << ptrr << endl; cout << "*ptrr의 값(num의 주소값 / ptr이 가르키는 주소값 == ptr이 담고있는 값.) : " << *ptrr <<     endl;
    cout << "**ptrr의 값(num의 값) : " << **ptrr << endl;    
}
```
위 소스와 같이 더블 포인터의 경우 포인터를 가르키는 포인터가 됩니다.
(그냥 이런게 있구나 하고 넘기셔도..)

포인터는 이쯤에서 마치려고 합니다.(사실 상수 포인터-const int*, int*const 도 있으나 생략하겠습니다..)
다음강에서는 바로 레퍼런스를 다룰 예정입니다.

